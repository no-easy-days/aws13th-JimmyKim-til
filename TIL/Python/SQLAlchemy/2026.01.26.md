# [2026-01-26]
## ☀️ 오늘의 목표 (Scrum)

- [ORM - SQLAlchemy 강의 및 실습]

## 📝 배운 내용 (Today I Learned)

## ORM 기초

1. DB Driver
 - DB - 프로그래밍 언어 간 "통역사" 역할

2. Design Pattern
 - 자주 발생하는 문제를 해결하는 검증된 설계 방식. (이럴 땐 이렇게 만들면 좋더라~)
 - 크게 Singleton(프로그램 전체에서 딱 하나만 존재하는 객체) / Factory(객체 생성 전담 공장) / Observer(상태 변화를 여러 곳에 알림)
   Strategy(알고리즘을 교체 가능하게 만드는 구조) / Decorator (기존에 새 기능을 덧붙임) 등이 있음
    > 디자인 패턴을 외우려하지말고, ***이 코드가 왜 복잡해지는가를 먼저 고민***하자.

3. 환경변수
 - 코드에 설정값을 넣으면 환경이 바뀔 때마다 코드 수정 & 이력 관리 어려움.
 - 앞에 온점(.)이 붙으면 모든 OS에서 "숨김 파일" 처리가 된다. 
 - 종류 
    1) .env : 보통, 협업할 때 .env.example 처럼 어떤 변수가 필요한지 정도는 기입해서 공유한다. 당연히 실제 값은 비워야함
    2) OS 환경변수 : 일반적으로는 테스트 용도
    3) 설정 파일(json, yaml) : 설정 구조가 복잡할 때, 계층적인 설정
    4) **클라우드 Secrets Manager** : 클라우드 업체에서 제공하는 비밀값 관리 서비스 (제일 많이 씀)
    5) Vault : 대규모 조직에서 활용하는 비밀값 관리 솔루션
    6) Docker/K8s 환경변수

4. 패러다임 불일치
  - 패러다임 : "본보기, 모범", 문제를 바라보고 해결하는 방식. 
  - 객체지향 언어 vs 절차지향 언어 등, **근본적으로 다른 철학**을 가지면 자주 발생함.
  - 상속 문제 → 객체 지향에서는 상속으로 코드 재사용이 가능하지만, RDBMS는 상속 미지원
  - 동기화 문제 → 객체지향 : 정의된 방향으로만 탐색 가능하고, 역방향은 별도 코드로 구현해야 하지만, RDBMS는 Foreign Key 쓰면 됨
  - 탐색 문제  → 객체지향 : 그래프 탐색으로 자유로움, RDBMS는 할 때마다 쿼리 작성해야함.
    > 이런 어려운 문제 때문에, ORM이 도입되었다.

5. ORM → ***SQLAlchemy***
  - 윗 예시와 같이 객체지향 프로그래밍 언어(Python)와 RDBMS를 연결해주는 것.
  - 클래스 정의만 하면 반복 코드를 자동으로 처리할 수 있고, 관계 탐색 시 SQL Join 사용 필요 없이 자동 매핑할 수 있다.

6. Session 관리
  - **Session : 어플리케이션과 DB 사이의 "대화창구"**
  - 매 요청마다 Session(engine)을 직접 생성하는건 코드가 중복 되고 번거롭다.
  - Session을 닫지 않으면 DB 연결이 고갈되거나 메모리 누수가 발생한다.
  - 여러 함수에서 같은 Session 공유를 실패하면 트랜젝션 일관성이 깨진다.
    > 실무에서는, 이런 문제 해결을 위해 ***sessionmaker***와 ***의존성 주입*** 패턴을 사용한다.
  1) sessionmaker : 매번 설정을 반복하지 않고 미리 설정된 Session을 찍어낼 수 있다.
     - Session(engine)의 경우 매번 설정을 직접 전달해야하지만, SessionLocal() 선언만 하면 호출 가능
  2) 의존성 주입(Dependency Injection, "DI") : get_db 패턴 구현한다.
     - **Generator 함수를 사용**하여 *Session의 생성과 정리를 자동화* 한다. (**yield 사용**)

7. N+1 문제
  - 1개의 쿼리만 날렸는데, N+1개의 쿼리가 실행되는 현상
  - SQLAlchemy의 relationship()은 기본적으로 ***Lazy Loading(지연 로딩)*** 전략을 사용한다.
     - Lazy Loading : 연관된 데이터를 실제로 접근할 때까지 로딩을 미루는 전략.
       1) 장점 → 메모리 절약 / 단일 객체 조회 시 속도 빠름 / 연관 데이터가 필요 없으면 효율적
       2) 단점 → ***반복 접근 시 N+1 문제 발생*** / 세션 종료 후 접근 불가 / 네트워크 왕복 비용 증가
  - **Eager Loading(즉시 로딩)** 전략을 활용하여 대응 할 수 있다.
     - Eager Loading : 메인 데이터 조회 시 **연관 데이터도 전부 함께 가져오는 전략**. 
       > joinedload(N:1관계, 단순 조회) / selectinload(1:N관계, 대량 데이터)를 활용하면 된다!

8. 관계 매핑
  - DB에서 Foreign Key로 표현하는 테이블 간 관계를 ORM 클래스 간의 참조 관계로 변환하는 것.
  - 기본적으로 ***relationship()은 리스트를 반환한다!***
  - relationship()을 사용하여 양방향 탐색 기능 지원함. (직접 연습해보면서 방향이 그려져야한다.)
  - 1:N 관계 → ***Foreign Key는 항상 N쪽 테이블에 위치***한다. 양쪽에 Relationship()
  - 1:1 관계 → Foreign Key에 UNIQUE 제약 조건(**unique=True**)을 추가한다. **uselist=False**로 단일 객체를 반환한다.
  - N:M 관계 → **중간 테이블(연결 테이블)**이 필요하고, 1:N 관계로 간소화한다.
  - back_populates를 활용하여 양방향 참조를 설정해야 하고, cascade 옵션으로 삭제 동작을 제어한다.

### 제너레이터와 yield에 대한 이해
일반적으로 함수는 어떤 결과값을 return 키워드를 이용해서 반환하는데, python에는 "yield"라는 놈이 있다. 그리고 yield는 **제너레이터**를 반환한다.
 - return : 결과값을 딱 한번만 제공, 모든 결과를 메모리에 올림 / ***yield : 결과값을 여러번 나누어 제공, 결과값을 하나씩 메모리에 올림***
 - 제너레이터(generator) : 여러 개의 데이터를 미리 만들어 두지 않음. **필요할 때마다 즉석에서 생성**하는 객체. 결과값을 나누어 받을 수 있다는 점에서 성능&메모리 측면에 이점이 있다.

## 🔥 도전 과제 & 해결 (Challenge & Solution)

> 오늘 겪은 문제나 도전적인 과제, 그리고 그것을 어떻게 해결했는지 기록합니다.
>
- **과제/문제**: ORM 실습
- **시도 및 해결**: 이해하느라 시간이 많이 걸렸는데 따라치니까 이해가 더 잘되었다.

## 💭 오늘의 회고 (Retrospective)

- **Keep (좋았던 점)**: 개념이해가 잘 되었다.
- **Problem (아쉬웠던 점)**: 시간이 좀 오래 걸리긴 했다.
- **Try (시도할 점)**: 이제 내일부터 다시 과제 돌입.

## 🔗 참고 자료 (References)

- [제너레이터 & yield 개념] https://www.daleseo.com/python-yield/
