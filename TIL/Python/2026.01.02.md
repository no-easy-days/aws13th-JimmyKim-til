# [2026-01-02]

## ☀️ 오늘의 목표 (Scrum)

- [Python 실습 문제 정복하기]

## 📝 배운 내용 (Today I Learned)

## Python 실습 과제 막혔던 부분들 정리

### 1. 클로저(Closure)
   - 자신이 생성된 환경(변수 포함)을 기억하는 것. 외부 함수가 끝나도, 내부 함수는 그때의 변수를 계속 사용할 수 있다.
   - 3가지 조건
     1) 중첩 함수 : 함수 안에 함수가 정의되어 있어야 한다.
     2) 외부 변수 참조 : 내부 함수가 외부 함수의 변수를 사용해야 한다.
     3) 내부 함수 반환 : 외부 함수가 내부 함수를 반환해야 한다.
   - 기본 구조
    ```
    def 외부함수(외부변수):	#1. 외부 함수
	def 내부함수(내부변수):		#2. 내부 함수("중첩"되었다.)
		return 외부변수 + 내부변수	#3. 외부 변수 참조

	return 내부함수	#4. 내부 함수 반환

    # 사용하려면
    클로저 = 외부함수(10)	#외부변수 = 10을 기억하는 함수 생성
    결과 = 클로저(5)	# 이렇게 하면, 10 + 5 = 15를 반환한다.
    ```
   - 각 클로저는 "자기만의 변수를 기억"한다. 서로에겐 영향 없음.
     > nonlocal : 외부 변수를 "클로저 내부에서 수정하는 로직"을 구현하고 싶을 때. 바로 바깥 함수의 변수를 수정한다.


### 2. 데코레이터(Decorator)
   - 원래의 함수 코드를 수정하지 않고, 기존 함수를 감싸서 추가 기능을 덧붙일 수 있다. 
   - 원본 함수에 아규먼트 값을 받는게 있으면 *args **kwargs로 받아서 전달한다.
     > *args : 위치 아규먼트를 tuple로 받음 / **kwargs : 키워드 아규먼트를 dictionary로 받음
   - 기본 구조
    ```
    def decorator(function):	# 원래 함수를 받음
         @functools.wraps # 항상 붙여주는게 좋다. 원본 함수의 메타 데이터를 불러와준다.   
         def wrapper(*args, **kwargs): # 감싸는 함수
              # 원래 함수(function) 실행 전 추가 작업
              result = function(*args, kwargs)
              # 원래 함수(function) 실행 후 추가 작업
              return result
          return wrapper # 감싸는 함수 반환
  
   @decorator 
   def function( ): # 원래 함수가 아니라 decorator 안에 있는 "wrapper 함수를 가리킨다"
       pass
    ```
   - @decorator는 프로그램이 로드될 때 실행된다. (원본 함수 호출 전에 이미 실행!)
   - 함수 위에 여러 개의 데코레이터를 붙일 수 있다!
      1) 감싸는(적용) 순서 : 아래 → 위 / 호출 순서 : 위 → 아래 (마치 양파처럼 되어있다고 생각해라.)


### 3. map, filter 복습
  - 결과를 바로 리스트로 주지 않고 "map/filter object(객체)" 를 반환한다. 메모리 효율성을 위한 Python의 특징.
  - 결과를 print로 찍어 보려면 list()로 감싸야 한다!
  - 사용 방법
  ``` 
    map(function, 반복 가능한 것)
    filter(Bool 반환 함수, 반복 가능한 것)  
  ```
  - 리스트 컴프리헨션해서 쓰려면 조건 순서를 맞춰야 한다. (안쪽에 있는걸 먼저, 그 다음 바깥쪽 조건)


### 4. 클래스
  > 객체를 만들기 위한 "설계도", 데이터를 구조화 할 때 / 상태값 관리할 때 가장 흔히 사용된다.
  - 클래스는 "한가지 역할" 만 하도록 만든다. 갓오브젝트가 되는걸 피해야한다. 이 것을 "단일 책임 원칙(SRP)" 으로 칭한다.
  1) 용어 정리
     - 인스턴스 : 클래스로 만들어진 "실제 객체"
     - 속성 : 객체가 가진 "데이터, 정보"
     - 메서드 : 객체가 할 수 있는 "특정 동작"
  ※ def __init__ 에서 소괄호 안에 들어 가는 건 외부 입력으로 생성자에 전달 되는 파라미터 값이다.
  > 어떤걸 외부에서 변수로 받고 어떤걸 __init__에서 생성해서 쓸 건지를 잘~~ 판단해야한다. "상태" 인지 "일시적인 값" 인지.
  - 메서드 안에서 self를 쓰는건, "__init__에서 이미 생성된 객체를 가져와라" 라는 뜻! 재선언하면 덮어써버린다.


### 5. 상속
  - 이미 만들어진 코드를 물려받아 재사용하는 것. 부모의 기능을 쓰고, 자식들은 기능을 추가할 수 있다.
  - 기본 문법
  ```
  class 부모클래스:
       ~~~~
       # 클래스 끝

  class 자식클래스(부모클래스): # 괄호 안에 부모 이름을 넣는다.
  ```
  - super() : 부모클래스를 가리키는 함수. 자식클래스에서 __init__을 새로 정의할 경우, 부모 클래스를 호출해야한다.
  - 메서드 오버라이딩 : 부모의 메서드를 자식이 덮어 써서 같은 이름으로 "재정의"하는 것.


### 6. 클래스 변수 vs 인스턴스 변수
  1) 클래스 변수
     - 클래스 바로 아래에 정의 / 모든 인스턴스가 공유해서 사용한다.
  2) 인스턴스 변수
     - __init__ (생성자 메서드) 안에서 self. 로 정의 / 각 인스턴스마다 별도로 사용한다.


### 7. 포함관계(Composition)
  - 하나의 클래스가 다른 클래스의 "객체"를 가져다가 리스트 or 딕셔너리 or 변수 형태로 쓰는 방식, 
  > 상속을 남용하면 "결합도"가 높아져 유지보수가 힘들다. 하여 상속 보다 포함 관계를 더 우선해서 사용하는게 관례.


### 8. 매직 메서드(Magic Method)
  - 언더바(__xxxx__) 형태로 이루어진 메서드, Python이 특정 상황에서 "자동으로 호출" 하는 것!
  - 사용 예시
    1) __init__ : 객체 생성 시 호출
    2) __str__ : print(), str() 사용 시 호출, 부모 클래스 선언 시 같이 정의해두면 출력문 찍기 용이함.


### 9. @classmethod, @staticmethod
  1) @classmethod : "팩토리 패턴"에 자주 쓰임. 여러 방식으로 객체를 생성
      - 첫번째 인자 : cls, 클래스 변수에만 접근 가능하다.
  2) @staticmethod : "유틸리티 함수"를 묶을 때 사용. Django / Flask 프레임워크에서 흔히 보임


### 10. 다중 상속
  > Mixin 패턴 (로깅, 직렬화 등 기능 조합)에 유용하지만, 조금 복잡하다. "다이아몬드 문제"를 일으킬 수 있다.


### 11. enumerate()
  - 순서를 매겨야 할 때 사용하면 좋은 함수
  ```
  for index, 요소값 in enumerate(대상 리스트, start=순번)
  ```


### 12. 데이터클래스(dataclass)
  - "@dataclass" 로 사용하고, 단순 데이터 저장용 클래스에 매우 빈번히 사용한다.
  - str / int / float 등등 어떤 자료형인지를 나타내는 "타입 힌트"를 사용해야 한다. '='로 기본값 지정 가능


### 13. 파일 입/출력
  - 기본 문법
  ```
  f = open('파일명', '모드', encoding='utf-8')
  ~~~~~~ # 비즈니스 로직 이어짐
  f.close()
  ```
  - 모드 : r(읽기) / w(쓰기, 기존 내용 날아감!) / a(추가) / x(파일 없을때만 생성) / b(바이너리모드) / +(갱신)
  - with 구문 : 자동으로 열린 파일을 close 해준다. 웬만하면 사용하자.
  1) 파일 읽기
     - read() : 파일 전체 내용 읽어오기
     - readline() : 파일 한줄씩 읽기
     - readlines() : 읽어온 파일을 리스트 자료형에 반환
     - strip(): 반복문과 함께 쓰이며, 큰 파일을 읽어올 때 권장된다
  2) 파일 쓰기
     - write() : 문자열 쓰기
     - writelines() : 리스트 자료형의 요소들을 파일에 쓰기 (개행이 필요할 경우 \n 넣어야 한다.)
     - print() 써도 되고, 모드를 'a'로 할당 후 문자열 입력해도 된다.


### 14. CSV
  1) csv 파일 읽기 : csv.reader
     - 첫번째 줄은 헤더 (제목), 나머지는 데이터
  2) 딕셔너리 자료형 형태로 읽어오기 : csv.DictReader ← "권장"
     - Row를 딕셔너리로 저장하고, Column명으로 접근 가능하다.
  3) csv 파일 쓰기 : csv.writer
  4) 딕셔너리 자료형 형태로 쓰기 : csv.DictWriter  ← "권장"
     - 변수를 딕셔너리 형태로 정의한 뒤 인자값으로 전달하면 된다.


### 15. JSON
   - 키-밸류 쌍으로 데이터를 표현하며, 딕셔너리 자료형과 거의 형태가 같다.
  1) json 파일 읽기 : json.load (파일에서 딕셔너리 자료형으로 저장)
  2) json 문자열 파싱 : json.loads (특정 문자열에서 읽기)
  3) json 파일 쓰기 : json.dump (당연히 딕셔너리 형태로 인자값을 전달해야 한다.)
   - JSON 파일은 주석 미지원한다! / CSV 파일에서 숫자가 스트링으로 읽히는 경우가 자주 있다.

## 🔥 도전 과제 & 해결 (Challenge & Solution)

> 오늘 겪은 문제나 도전적인 과제, 그리고 그것을 어떻게 해결했는지 기록합니다.
>
- **과제/문제**: 클래스 심화 개념
- **시도 및 해결**: 아직은 어렵다... 다음에 다시 복습할 내용이 많다.

## 💭 오늘의 회고 (Retrospective)

- **Keep (좋았던 점)**: 클래스 실습문제 풀면서 뭔가 깨달음을 얻었다.
- **Problem (아쉬웠던 점)**: 아직까지 어려운 개념이 많다. 데코레이터, 클로저, 클래스 상속 등등 ㅠ
- **Try (시도할 점)**: 내일 실습문제 & 개념 학습 다 마무리하고 도서관 퀘스트 수행해보자.

## 🔗 참고 자료 (References)

- [링크 제목](https://www.google.com/search?q=URL)
